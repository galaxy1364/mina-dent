#!/usr/bin/env bash
# LOCKPACK_AUTOGUARD_BEGIN
set -euo pipefail

ROOT_DIR="\C:/work/mina-dent_WORK"
OUT_DIR="\/LOCKPACK/out"
mkdir -p "\"

# always keep a log file, even on failure
LOG_FILE="\/project.log"
touch "\"

write_minimal_manifest() {
  # minimal machine-readable manifest (no secrets)
  cat > "\/manifest.json" <<'JSON'
{
  "lockpack": {
    "version": "v8",
    "generated_at_utc": "",
    "note": "minimal manifest generated by runner trap"
  }
}
JSON
}

write_minimal_qg_fail() {
  # minimal QG.json that still fails gates (errors>0), but is machine-readable
  cat > "\/QG.json" <<'JSON'
{
  "overall": "FAIL",
  "errors": 1,
  "pending": 0,
  "aborted": 0,
  "notes": ["QG auto-generated by runner trap due to early failure or missing outputs"]
}
JSON
}

finalize_trap() {
  ec=\True
  # If outputs are missing, create minimal ones so evidence upload never becomes empty.
  if [ ! -f "\/manifest.json" ]; then
    write_minimal_manifest || true
  fi
  if [ ! -f "\/QG.json" ]; then
    write_minimal_qg_fail || true
  fi
  if [ ! -f "\" ]; then
    echo "log missing; created by trap" > "\" || true
  fi

  # stamp manifest time (best-effort)
  if command -v date >/dev/null 2>&1; then
    ts=\2026-01-01T13:34:59Z
    # replace only first occurrence of empty generated_at_utc
    perl -0777 -i -pe "s/\"generated_at_utc\": \"\"/\"generated_at_utc\": \"\\"/s" "\/manifest.json" 2>/dev/null || true
  fi

  exit \
}
trap finalize_trap EXIT

# LOCKPACK_AUTOGUARD_END
set -euo pipefail

HARD_TIMEOUT_MS="${HARD_TIMEOUT_MS:-600000}" # 10m hard cap
START_TS="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

REPO="${GITHUB_REPOSITORY:-unknown}"
WF="${GITHUB_WORKFLOW:-unknown}"
RUN_ID="${GITHUB_RUN_ID:-unknown}"
SHA="${GITHUB_SHA:-unknown}"
REF="${GITHUB_REF:-unknown}"

mkdir -p lockpack/out

JS_ERRORS_COUNT=0
PENDING_COUNT=0
ABORT_OK=true

if [[ -f "lockpack/project-lockpack.sh" ]]; then
  echo "Found lockpack/project-lockpack.sh -> executing with hard timeout ${HARD_TIMEOUT_MS}ms"
  SEC=$(( (HARD_TIMEOUT_MS + 999) / 1000 ))
  if ! timeout "${SEC}"s bash lockpack/project-lockpack.sh > lockpack/out/project.log 2>&1; then
    ABORT_OK=false
    echo "project-lockpack timed out or failed; see lockpack/out/project.log" >&2
  fi
else
  echo "No project lockpack harness found; checks recorded as SKIPPED where applicable"
fi

OVERALL="PASS"
if [[ "${JS_ERRORS_COUNT}" -gt 0 ]]; then OVERALL="FAIL"; fi
if [[ "${PENDING_COUNT}" -gt 0 ]]; then OVERALL="FAIL"; fi
if [[ "${ABORT_OK}" != "true" ]]; then OVERALL="FAIL"; fi

cat > lockpack/out/QG.json <<EOF
{
  "version": "1.0.0",
  "run": {
    "repo": "${REPO}",
    "workflow": "${WF}",
    "run_id": "${RUN_ID}",
    "sha": "${SHA}",
    "ref": "${REF}",
    "ts_utc": "${START_TS}"
  },
  "checks": {
    "js_errors": { "count": ${JS_ERRORS_COUNT}, "details": [] },
    "pending":   { "count": ${PENDING_COUNT},  "details": [] },
    "abort_safe":{ "ok": ${ABORT_OK},          "details": [] },
    "timeouts_ms": { "hard_timeout_ms": ${HARD_TIMEOUT_MS} }
  },
  "overall": "${OVERALL}"
}
EOF

python - <<'PY'
import hashlib, json, pathlib
root = pathlib.Path(".")
paths = [
  ".github/workflows/lockpack-ci.yml",
  ".gitattributes",
  ".github/CODEOWNERS",
  "lockpack/run-lockpack.sh",
  "lockpack/qg.schema.json",
]
items = []
for p in paths:
  fp = root / p
  if fp.exists():
    items.append({"path": p, "sha256": hashlib.sha256(fp.read_bytes()).hexdigest()})
  else:
    items.append({"path": p, "missing": True})
out = {"version":"1.0.0","items":items}
(root/"lockpack/out/manifest.json").write_text(json.dumps(out, indent=2), encoding="utf-8")
PY

echo "QG written: lockpack/out/QG.json"
echo "Manifest:  lockpack/out/manifest.json"

if [[ "${OVERALL}" != "PASS" ]]; then
  echo "LOCKPACK OVERALL=${OVERALL} -> failing job"
  exit 1
fi

# --- LOCKPACK HARD EVIDENCE GATE ---
if [ ! -f "\/QG.json" ]; then echo "LOCKPACK: Missing \/QG.json" >&2; exit 2; fi
if [ ! -f "\/manifest.json" ]; then echo "LOCKPACK: Missing \/manifest.json" >&2; exit 3; fi
if [ ! -f "\/project.log" ]; then echo "LOCKPACK: Missing \/project.log" >&2; exit 4; fi
# ---------------------------------
